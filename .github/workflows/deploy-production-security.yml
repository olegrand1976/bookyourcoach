name: üöÄ D√©ploiement Production avec Corrections de S√©curit√©

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      skip_build:
        description: 'Ignorer le build (d√©ployer seulement)'
        required: false
        default: 'false'
        type: boolean
      skip_deploy:
        description: 'Ignorer le d√©ploiement (build seulement)'
        required: false
        default: 'false'
        type: boolean
      force_rebuild:
        description: 'Forcer la reconstruction des images'
        required: false
        default: 'false'
        type: boolean
      security_fixes:
        description: 'Appliquer les corrections de s√©curit√©'
        required: false
        default: 'true'
        type: boolean

env:
  DOCKER_REGISTRY: docker.io
  IMAGE_NAME: ${{ vars.DOCKERHUB_USERNAME }}/activibe-app
  FRONTEND_IMAGE_NAME: ${{ vars.DOCKERHUB_USERNAME }}/activibe-frontend
  COMPOSE_FILE: docker-compose.yml
  ENV_FILE: production.env

jobs:
  # Job 1: Pr√©paration et validation
  prepare:
    name: üîç Pr√©paration & Validation
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      image_tag: ${{ steps.check.outputs.image_tag }}
      apply_security: ${{ steps.check.outputs.apply_security }}
    
    steps:
    - name: üì• Checkout du code
      uses: actions/checkout@v4
      
    - name: üîç V√©rification des conditions
      id: check
      run: |
        # Initialiser les variables avec des valeurs par d√©faut
        SKIP_BUILD="${{ inputs.skip_build }}"
        SKIP_DEPLOY="${{ inputs.skip_deploy }}"
        SECURITY_FIXES="${{ inputs.security_fixes }}"
        FORCE_REBUILD="${{ inputs.force_rebuild }}"
        
        # D√©terminer si on doit builder (par d√©faut: true)
        if [[ "$SKIP_BUILD" == "true" ]]; then
          SHOULD_BUILD="false"
        else
          SHOULD_BUILD="true"
        fi
        
        # D√©terminer si on doit d√©ployer (par d√©faut: true)
        if [[ "$SKIP_DEPLOY" == "true" ]]; then
          SHOULD_DEPLOY="false"
        else
          SHOULD_DEPLOY="true"
        fi
        
        # D√©terminer si on applique les corrections de s√©curit√© (par d√©faut: true)
        if [[ "$SECURITY_FIXES" == "false" ]]; then
          APPLY_SECURITY="false"
        else
          APPLY_SECURITY="true"
        fi
        
        # G√©n√©rer le tag d'image
        if [[ "$FORCE_REBUILD" == "true" ]]; then
          IMAGE_TAG="security-fix-$(date +%s)"
        else
          IMAGE_TAG="${{ github.sha }}"
        fi
        
        # √âcrire les outputs
        echo "should_build=$SHOULD_BUILD" >> $GITHUB_OUTPUT
        echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
        echo "apply_security=$APPLY_SECURITY" >> $GITHUB_OUTPUT
        echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        
        # Afficher les valeurs pour d√©bogage
        echo "üîç Conditions v√©rifi√©es :"
        echo "  - Build: $SHOULD_BUILD"
        echo "  - Deploy: $SHOULD_DEPLOY"
        echo "  - Security fixes: $APPLY_SECURITY"
        echo "  - Tag: $IMAGE_TAG"

  # Job 2: V√©rification des corrections de s√©curit√©
  security-check:
    name: üîí V√©rification S√©curit√©
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.apply_security == 'true'
    
    steps:
    - name: üì• Checkout du code
      uses: actions/checkout@v4
      
    - name: üîç V√©rification des fichiers de s√©curit√©
      run: |
        echo "üîí V√©rification des corrections de s√©curit√©..."
        
        # V√©rifier que les fichiers de s√©curit√© existent
        security_files=(
          "app/Http/Controllers/Api/AdminController.php"
          "app/Http/Controllers/Api/TeacherController.php"
          "app/Http/Controllers/Api/StudentController.php"
          "app/Http/Controllers/Api/FileUploadController.php"
          "routes/api.php"
          "routes/admin.php"
          "bootstrap/app.php"
        )
        
        missing_files=()
        for file in "${security_files[@]}"; do
          if [ -f "$file" ]; then
            echo "‚úÖ Fichier s√©curis√©: $file"
          else
            echo "‚ùå Fichier manquant: $file"
            missing_files+=("$file")
          fi
        done
        
        if [ ${#missing_files[@]} -gt 0 ]; then
          echo "‚ùå Fichiers de s√©curit√© manquants d√©tect√©s!"
          exit 1
        fi
        
        # V√©rifier la syntaxe PHP
        echo "üîç V√©rification de la syntaxe PHP..."
        php -l routes/api.php
        php -l routes/admin.php
        php -l app/Http/Controllers/Api/AdminController.php
        php -l app/Http/Controllers/Api/TeacherController.php
        php -l app/Http/Controllers/Api/StudentController.php
        php -l app/Http/Controllers/Api/FileUploadController.php
        
        # V√©rifier l'absence d'authentification manuelle
        echo "üîç V√©rification de l'authentification manuelle..."
        manual_auth=$(grep -c "request()->header('Authorization')" routes/api.php || echo "0")
        role_checks=$(grep -c "role !== 'admin'" routes/api.php || echo "0")
        
        if [ $manual_auth -gt 0 ]; then
          echo "‚ùå Authentifications manuelles d√©tect√©es: $manual_auth"
          exit 1
        fi
        
        if [ $role_checks -gt 0 ]; then
          echo "‚ùå V√©rifications de r√¥le d√©tect√©es: $role_checks"
          exit 1
        fi
        
        echo "‚úÖ Toutes les v√©rifications de s√©curit√© sont pass√©es!"
        echo "  - Authentifications manuelles: $manual_auth"
        echo "  - V√©rifications de r√¥le: $role_checks"

  # Job 3: Build des images Docker
  build-images:
    name: üèóÔ∏è Build Images Docker
    runs-on: ubuntu-latest
    needs: [prepare, security-check]
    if: needs.prepare.outputs.should_build == 'true'
    outputs:
      backend_image: ${{ steps.build-backend.outputs.image }}
      frontend_image: ${{ steps.build-frontend.outputs.image }}
    
    steps:
    - name: üì• Checkout du code
      uses: actions/checkout@v4
      
    - name: üê≥ Configuration Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: üîê Connexion DockerHub
      uses: docker/login-action@v3
      with:
        registry: docker.io
        username: ${{ vars.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_PASSWORD }}
    
    - name: üèóÔ∏è Build Backend (Laravel) avec corrections de s√©curit√©
      id: build-backend
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64
        push: true
        tags: |
          ${{ env.IMAGE_NAME }}:latest
          ${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.image_tag }}
          ${{ env.IMAGE_NAME }}:security-fixed
        cache-from: type=gha,scope=backend
        cache-to: type=gha,mode=max,scope=backend
        build-args: |
          SECURITY_FIXES=true
          BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
      continue-on-error: false

    - name: üé® Build Frontend (Nuxt.js)
      id: build-frontend
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        platforms: linux/amd64
        push: true
        tags: |
          ${{ env.FRONTEND_IMAGE_NAME }}:latest
          ${{ env.FRONTEND_IMAGE_NAME }}:${{ needs.prepare.outputs.image_tag }}
        cache-from: type=gha,scope=frontend
        cache-to: type=gha,mode=max,scope=frontend
      continue-on-error: false

    - name: üìã R√©sum√© du build
      run: |
        echo "‚úÖ Build termin√© avec succ√®s !"
        echo "üèóÔ∏è Images construites avec corrections de s√©curit√© :"
        echo "  - Backend: ${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.image_tag }}"
        echo "  - Frontend: ${{ env.FRONTEND_IMAGE_NAME }}:${{ needs.prepare.outputs.image_tag }}"
        echo "üîí Corrections de s√©curit√© int√©gr√©es :"
        echo "  - Authentification centralis√©e avec auth:sanctum"
        echo "  - Middlewares de r√¥les appropri√©s"
        echo "  - Contr√¥leurs s√©curis√©s"
        echo "  - Suppression de l'authentification manuelle"

  # Job 4: G√©n√©ration des fichiers de configuration avec s√©curit√©
  generate-config:
    name: ‚öôÔ∏è G√©n√©ration Configuration S√©curis√©e
    runs-on: ubuntu-latest
    needs: [prepare, build-images]
    if: needs.prepare.outputs.should_deploy == 'true'
    outputs:
      config_files: ${{ steps.generate.outputs.files }}
    
    steps:
    - name: üì• Checkout du code
      uses: actions/checkout@v4
      
    - name: ‚öôÔ∏è G√©n√©ration des fichiers de configuration s√©curis√©s
      id: generate
      run: |
        echo "üîß G√©n√©ration des fichiers de configuration avec s√©curit√©..."
        
        # G√©n√©rer APP_KEY
        APP_KEY=$(openssl rand -base64 32)
        
        # Cr√©er docker-compose.yml avec s√©curit√© renforc√©e
        cat > docker-compose.yml << 'EOF'
        services:
          # Backend Laravel API avec s√©curit√© renforc√©e
          backend:
            image: ${IMAGE_NAME:-${{ env.IMAGE_NAME }}:latest}
            container_name: activibe-backend
            restart: unless-stopped
            env_file:
              - ./.env
            ports:
              - "8080:80"
            volumes:
              - app_storage:/var/www/storage
              - app_bootstrap_cache:/var/www/bootstrap/cache
              - /srv/activibe/cert.pem:/var/www/html/cert.pem:ro
              - /srv/activibe/.env:/var/www/html/.env:ro
            depends_on:
              - neo4j
            networks:
              - app-network
            security_opt:
              - no-new-privileges:true
            read_only: true
            tmpfs:
              - /tmp
              - /var/tmp

          # Frontend Nuxt.js
          frontend:
            image: ${FRONTEND_IMAGE_NAME:-${{ env.FRONTEND_IMAGE_NAME }}:latest}
            container_name: activibe-frontend
            restart: unless-stopped
            ports:
              - "3000:3000"
            environment:
              - NUXT_PUBLIC_API_BASE=https://activibe.be/api
              - NUXT_API_BASE=http://activibe-backend:80/api
              - NITRO_HOST=0.0.0.0
              - NITRO_PORT=3000
            depends_on:
              - backend
            networks:
              - app-network
            security_opt:
              - no-new-privileges:true

          # phpMyAdmin
          phpmyadmin:
            image: phpmyadmin:latest
            container_name: activibe-phpmyadmin
            restart: unless-stopped
            ports:
              - "8082:80"
            environment:
              - PMA_HOST=${DB_HOST}
              - PMA_PORT=${DB_PORT}
              - PMA_USER=${DB_USERNAME}
              - PMA_PASSWORD=${DB_PASSWORD}
              - UPLOAD_LIMIT=256M
              - MEMORY_LIMIT=512M
            networks:
              - app-network
            security_opt:
              - no-new-privileges:true

          # Neo4j
          neo4j:
            image: neo4j:5.15-community
            container_name: activibe-neo4j
            restart: unless-stopped
            ports:
              - "7474:7474"
              - "7687:7687"
            environment:
              - NEO4J_AUTH=neo4j/${NEO4J_PASSWORD}
              - NEO4J_PLUGINS=["apoc"]
              - NEO4J_dbms_security_procedures_unrestricted=apoc.*
              - NEO4J_dbms_security_procedures_allowlist=apoc.*
            volumes:
              - neo4j_data:/data
              - neo4j_logs:/logs
              - neo4j_import:/var/lib/neo4j/import
              - neo4j_plugins:/plugins
            networks:
              - app-network
            security_opt:
              - no-new-privileges:true

        volumes:
          neo4j_data:
            driver: local
          neo4j_logs:
            driver: local
          neo4j_import:
            driver: local
          neo4j_plugins:
            driver: local
          app_storage:
            driver: local
          app_bootstrap_cache:
            driver: local

        networks:
          app-network:
            driver: bridge
        EOF

        # Cr√©er le script de d√©ploiement s√©curis√©
        cat > auto-deploy-secure.sh << 'EOF'
        #!/bin/bash
        set -e
        
        # Couleurs
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        BLUE='\033[0;34m'
        NC='\033[0m'

        log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
        log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
        log_error() { echo -e "${RED}[ERROR]${NC} $1"; }
        log_step() { echo -e "${BLUE}[STEP]${NC} $1"; }

        COMPOSE_FILE="docker-compose.yml"
        ENV_FILE=".env"

        log_step "üöÄ D√©marrage du d√©ploiement s√©curis√©..."

        # Arr√™t et suppression explicite des containers existants par nom
        log_info "üõë Arr√™t et suppression des containers existants..."
        CONTAINERS=("activibe-backend" "activibe-frontend" "activibe-phpmyadmin" "activibe-neo4j")
        for container in "${CONTAINERS[@]}"; do
            # Forcer l'arr√™t et la suppression sans v√©rification pr√©alable
            log_info "  Arr√™t et suppression de ${container}..."
            docker stop "${container}" 2>/dev/null || true
            docker rm -f "${container}" 2>/dev/null || true
            # V√©rifier que le conteneur a bien √©t√© supprim√©
            if docker ps -a --format '{{.Names}}' | grep -q "^${container}$"; then
                log_warning "  ‚ö†Ô∏è  Le conteneur ${container} existe encore, nouvelle tentative..."
                docker rm -f "${container}" 2>/dev/null || true
            fi
        done

        # Arr√™t propre avec docker compose si le fichier existe
        if [[ -f "$COMPOSE_FILE" ]]; then
            log_info "üõë Arr√™t avec docker compose..."
            docker compose -f "$COMPOSE_FILE" down --remove-orphans 2>/dev/null || true
            # Attendre un peu pour que les conteneurs soient bien arr√™t√©s
            sleep 2
        fi

        # Suppression finale forc√©e de tous les conteneurs par nom (au cas o√π)
        log_info "üóëÔ∏è  Suppression finale forc√©e des conteneurs..."
        for container in "${CONTAINERS[@]}"; do
            docker rm -f "${container}" 2>/dev/null || true
        done

        # Suppression explicite des r√©seaux existants
        log_info "üóëÔ∏è  Suppression des r√©seaux existants..."
        NETWORKS=("activibe_app-network" "app-network" "bookyourcoach-network")
        for network in "${NETWORKS[@]}"; do
            if docker network ls --format '{{.Name}}' | grep -q "^${network}$"; then
                log_info "  Suppression du r√©seau ${network}..."
                docker network rm "${network}" 2>/dev/null || true
            fi
        done

        # Nettoyage des ressources orphelines
        log_info "üßπ Nettoyage des ressources orphelines..."
        docker container prune -f 2>/dev/null || true
        docker network prune -f 2>/dev/null || true

        # Pull des images avec corrections de s√©curit√©
        log_info "üì• R√©cup√©ration des images avec corrections de s√©curit√©..."
        if [[ -f "$ENV_FILE" ]]; then
            source "$ENV_FILE" || true
        else
            log_warning "Fichier $ENV_FILE non trouv√© - utilisation des variables d'environnement par d√©faut"
        fi
        docker pull "$2:latest" || { log_error "Impossible de pull l'image backend"; exit 1; }
        docker pull "$3:latest" || { log_error "Impossible de pull l'image frontend"; exit 1; }

        # D√©marrage avec docker compose
        log_info "üöÄ D√©marrage des conteneurs s√©curis√©s..."
        if ! docker compose -f "$COMPOSE_FILE" up -d --remove-orphans; then
            log_error "√âchec du d√©marrage des conteneurs"
            docker compose -f "$COMPOSE_FILE" ps
            docker compose -f "$COMPOSE_FILE" logs --tail=50
            exit 1
        fi

        # Fonction pour attendre qu'un service soit pr√™t
        wait_for_service() {
            local service=$1
            local url=$2
            local max_attempts=${3:-30}
            local attempt=0
            
            log_info "‚è≥ Attente que ${service} soit pr√™t..."
            while [ $attempt -lt $max_attempts ]; do
                if curl -f -s "${url}" >/dev/null 2>&1; then
                    log_info "‚úÖ ${service} est pr√™t (tentative $((attempt + 1)))"
                    return 0
                fi
                attempt=$((attempt + 1))
                sleep 1
            done
            log_warning "‚ö†Ô∏è  ${service} n'est pas pr√™t apr√®s ${max_attempts} secondes"
            return 1
        }

        # V√©rification que les conteneurs sont d√©marr√©s
        log_info "üîç V√©rification du d√©marrage des conteneurs..."
        sleep 2
        FAILED_CONTAINERS=$(docker compose -f "$COMPOSE_FILE" ps --format json | jq -r 'select(.State == "exited" or .State == "restarting") | .Name' 2>/dev/null || true)
        if [ -n "$FAILED_CONTAINERS" ]; then
            log_error "Certains conteneurs ont √©chou√© :"
            echo "$FAILED_CONTAINERS"
            docker compose -f "$COMPOSE_FILE" ps
            docker compose -f "$COMPOSE_FILE" logs --tail=50
            exit 1
        fi

        # Attente intelligente du d√©marrage des services (maximum 30 secondes)
        log_info "‚è≥ Attente du d√©marrage des services..."
        wait_for_service "Backend" "http://localhost:8080" 30 || true
        wait_for_service "Frontend" "http://localhost:3000" 20 || true

        # Initialisation de l'application avec s√©curit√©
        log_info "üîß Initialisation de l'application..."
        MAX_RETRIES=10
        RETRY_COUNT=0
        
        # Attendre que le backend soit vraiment pr√™t
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if docker compose -f "$COMPOSE_FILE" exec -T backend php artisan --version >/dev/null 2>&1; then
                log_info "‚úÖ Backend pr√™t (tentative $((RETRY_COUNT + 1)))"
                break
            fi
            RETRY_COUNT=$((RETRY_COUNT + 1))
            log_warning "Tentative $RETRY_COUNT/$MAX_RETRIES - Attente du backend..."
            sleep 3
        done
        
        if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            log_error "Impossible d'ex√©cuter les commandes artisan - le backend n'est pas pr√™t"
            docker compose -f "$COMPOSE_FILE" logs backend --tail=50
        else
            # Nettoyage complet de tous les caches et r√©g√©n√©ration de l'autoloader
            log_info "üßπ Nettoyage complet des caches..."
            
            # Supprimer manuellement les fichiers de cache corrompus
            docker compose -f "$COMPOSE_FILE" exec -T backend rm -rf bootstrap/cache/*.php 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend rm -rf storage/framework/cache/data/* 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend rm -rf storage/framework/views/* 2>/dev/null || true
            
            # Nettoyer avec artisan
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan optimize:clear 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan config:clear 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan cache:clear 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan route:clear 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan view:clear 2>/dev/null || true
            
            # R√©g√©n√©rer l'autoloader Composer (important pour les service providers)
            log_info "üîÑ R√©g√©n√©ration de l'autoloader Composer..."
            docker compose -f "$COMPOSE_FILE" exec -T backend composer dump-autoload --optimize 2>/dev/null || true
            
            # Recr√©er les caches optimis√©s (sans view:cache car cela peut causer des probl√®mes)
            log_info "‚ö° Optimisation des caches..."
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan config:cache 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan route:cache 2>/dev/null || true
            
            # V√©rifier que l'application fonctionne
            log_info "üîç V√©rification de l'application..."
            sleep 3
            
            # Test rapide pour v√©rifier que le service view est disponible
            if docker compose -f "$COMPOSE_FILE" exec -T backend php artisan tinker --execute="app('view'); echo 'OK';" 2>/dev/null | grep -q "OK"; then
                log_info "‚úÖ Service 'view' disponible"
            else
                log_warning "‚ö†Ô∏è  Service 'view' non disponible - red√©marrage du conteneur..."
                docker compose -f "$COMPOSE_FILE" restart backend
                sleep 5
            fi
        fi

        # V√©rification de l'√©tat des services
        log_step "üîç V√©rification de l'√©tat des services..."
        docker compose -f "$COMPOSE_FILE" ps

        # Tests de connectivit√© et s√©curit√©
        log_step "üß™ Tests de connectivit√© et s√©curit√©..."
        
        # Test du backend Laravel (port 8080) avec diagnostic d√©taill√©
        backend_response=$(curl -s -w "\n%{http_code}" http://localhost:8080 2>/dev/null)
        backend_http_code=$(echo "$backend_response" | tail -n 1)
        
        if [ "$backend_http_code" = "200" ] || [ "$backend_http_code" = "302" ] || [ "$backend_http_code" = "404" ]; then
            log_info "‚úÖ Port 8080 (Backend Laravel) : Accessible (HTTP $backend_http_code)"
        elif [ "$backend_http_code" = "500" ]; then
            log_error "‚ùå Port 8080 (Backend Laravel) : Erreur serveur (HTTP 500)"
            log_info "üìã V√©rification des logs du backend..."
            docker compose -f "$COMPOSE_FILE" logs backend --tail=30
            log_info "üîß Tentative de correction compl√®te..."
            
            # Supprimer les caches corrompus
            docker compose -f "$COMPOSE_FILE" exec -T backend rm -rf bootstrap/cache/*.php 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend rm -rf storage/framework/cache/data/* 2>/dev/null || true
            
            # Nettoyer et r√©g√©n√©rer
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan optimize:clear 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend composer dump-autoload --optimize 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan config:cache 2>/dev/null || true
            
            # Red√©marrer le conteneur
            log_info "üîÑ Red√©marrage du conteneur backend..."
            docker compose -f "$COMPOSE_FILE" restart backend
            sleep 5
        else
            log_warning "‚ö†Ô∏è  Port 8080 (Backend Laravel) : Non accessible (HTTP ${backend_http_code:-unknown})"
        fi

        # Test de s√©curit√© des routes admin (seulement si le backend r√©pond correctement)
        if [ "$backend_http_code" != "500" ] && [ -n "$backend_http_code" ]; then
            admin_response=$(curl -s -w "\n%{http_code}" -H "Authorization: Bearer invalid_token" http://localhost:8080/api/admin/dashboard 2>/dev/null)
            admin_http_code=$(echo "$admin_response" | tail -n 1)
            
            if [ "$admin_http_code" = "401" ]; then
                log_info "‚úÖ Routes admin s√©curis√©es (HTTP $admin_http_code)"
            else
                log_warning "‚ö†Ô∏è  Routes admin non s√©curis√©es (HTTP $admin_http_code)"
            fi

            # Test de s√©curit√© des routes teacher
            teacher_response=$(curl -s -w "\n%{http_code}" -H "Authorization: Bearer invalid_token" http://localhost:8080/api/teacher/dashboard 2>/dev/null)
            teacher_http_code=$(echo "$teacher_response" | tail -n 1)
            
            if [ "$teacher_http_code" = "401" ]; then
                log_info "‚úÖ Routes teacher s√©curis√©es (HTTP $teacher_http_code)"
            else
                log_warning "‚ö†Ô∏è  Routes teacher non s√©curis√©es (HTTP $teacher_http_code)"
            fi
        else
            log_warning "‚ö†Ô∏è  Tests de s√©curit√© ignor√©s - backend non accessible (HTTP $backend_http_code)"
        fi

        # Test du frontend Nuxt.js (port 3000)
        if curl -f http://localhost:3000 >/dev/null 2>&1; then
            log_info "‚úÖ Port 3000 (Frontend Nuxt.js) : Accessible"
        else
            log_warning "‚ö†Ô∏è  Port 3000 (Frontend Nuxt.js) : Non accessible"
        fi

        # Test port 7474 (Neo4j)
        if curl -f http://localhost:7474 >/dev/null 2>&1; then
            log_info "‚úÖ Port 7474 (Neo4j) : Accessible"
        else
            log_warning "‚ö†Ô∏è  Port 7474 (Neo4j) : Non accessible"
        fi

        log_step "‚úÖ D√©ploiement s√©curis√© termin√© !"
        log_info "üîí Corrections de s√©curit√© appliqu√©es :"
        log_info "  - Authentification centralis√©e avec auth:sanctum"
        log_info "  - Middlewares de r√¥les appropri√©s"
        log_info "  - Suppression de l'authentification manuelle"
        log_info "  - Contr√¥leurs s√©curis√©s"
        EOF
        
        chmod +x auto-deploy-secure.sh

        echo "files=docker-compose.yml,auto-deploy-secure.sh" >> $GITHUB_OUTPUT
        echo "‚úÖ Fichiers de configuration s√©curis√©s g√©n√©r√©s avec succ√®s !"

  # Job 5: D√©ploiement sur le serveur avec s√©curit√©
  deploy:
    name: üöÄ D√©ploiement Serveur S√©curis√©
    runs-on: ubuntu-latest
    needs: [prepare, build-images, generate-config]
    if: needs.prepare.outputs.should_deploy == 'true'
    
    steps:
    - name: üì• Checkout du code
      uses: actions/checkout@v4
      
    - name: üîë Configuration SSH
      run: |
        echo "üîß Configuration de la connexion SSH..."
        mkdir -p ~/.ssh
        echo "${{ secrets.SERVER_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        cat > ~/.ssh/config << EOF
        Host production-server
          HostName ${{ vars.SERVER_HOST }}
          User ${{ vars.SERVER_USERNAME }}
          Port ${{ vars.SERVER_PORT }}
          IdentityFile ~/.ssh/id_rsa
          StrictHostKeyChecking no
          UserKnownHostsFile /dev/null
        EOF
        
        chmod 600 ~/.ssh/config

    - name: ‚öôÔ∏è G√©n√©ration des fichiers de configuration s√©curis√©s
      run: |
        echo "üîß G√©n√©ration des fichiers de configuration avec s√©curit√©..."
        
        # G√©n√©rer APP_KEY
        APP_KEY=$(openssl rand -base64 32)
        
        # Cr√©er docker-compose.yml avec s√©curit√© renforc√©e
        cat > docker-compose.yml << 'EOF'
        services:
          # Backend Laravel API avec s√©curit√© renforc√©e
          backend:
            image: ${IMAGE_NAME:-${{ env.IMAGE_NAME }}:latest}
            container_name: activibe-backend
            restart: unless-stopped
            env_file:
              - ./.env
            ports:
              - "8080:80"
            volumes:
              - app_storage:/var/www/storage
              - app_bootstrap_cache:/var/www/bootstrap/cache
              - /srv/activibe/cert.pem:/var/www/html/cert.pem:ro
              - /srv/activibe/.env:/var/www/html/.env:ro
            depends_on:
              - neo4j
            networks:
              - app-network
            security_opt:
              - no-new-privileges:true
            read_only: true
            tmpfs:
              - /tmp
              - /var/tmp

          # Frontend Nuxt.js
          frontend:
            image: ${FRONTEND_IMAGE_NAME:-${{ env.FRONTEND_IMAGE_NAME }}:latest}
            container_name: activibe-frontend
            restart: unless-stopped
            ports:
              - "3000:3000"
            environment:
              - NUXT_PUBLIC_API_BASE=https://activibe.be/api
              - NUXT_API_BASE=http://activibe-backend:80/api
              - NITRO_HOST=0.0.0.0
              - NITRO_PORT=3000
            depends_on:
              - backend
            networks:
              - app-network
            security_opt:
              - no-new-privileges:true

          # phpMyAdmin
          phpmyadmin:
            image: phpmyadmin:latest
            container_name: activibe-phpmyadmin
            restart: unless-stopped
            ports:
              - "8082:80"
            environment:
              - PMA_HOST=${DB_HOST}
              - PMA_PORT=${DB_PORT}
              - PMA_USER=${DB_USERNAME}
              - PMA_PASSWORD=${DB_PASSWORD}
              - UPLOAD_LIMIT=256M
              - MEMORY_LIMIT=512M
            networks:
              - app-network
            security_opt:
              - no-new-privileges:true

          # Neo4j
          neo4j:
            image: neo4j:5.15-community
            container_name: activibe-neo4j
            restart: unless-stopped
            ports:
              - "7474:7474"
              - "7687:7687"
            environment:
              - NEO4J_AUTH=neo4j/${NEO4J_PASSWORD}
              - NEO4J_PLUGINS=["apoc"]
              - NEO4J_dbms_security_procedures_unrestricted=apoc.*
              - NEO4J_dbms_security_procedures_allowlist=apoc.*
            volumes:
              - neo4j_data:/data
              - neo4j_logs:/logs
              - neo4j_import:/var/lib/neo4j/import
              - neo4j_plugins:/plugins
            networks:
              - app-network
            security_opt:
              - no-new-privileges:true

        volumes:
          neo4j_data:
            driver: local
          neo4j_logs:
            driver: local
          neo4j_import:
            driver: local
          neo4j_plugins:
            driver: local
          app_storage:
            driver: local
          app_bootstrap_cache:
            driver: local

        networks:
          app-network:
            driver: bridge
        EOF

        # Cr√©er le script de d√©ploiement s√©curis√©
        cat > auto-deploy-secure.sh << 'EOF'
        #!/bin/bash
        set -e
        
        # Couleurs
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        BLUE='\033[0;34m'
        NC='\033[0m'

        log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
        log_warning() { echo -e "${YELLOW}[WARNING]${NC} $1"; }
        log_error() { echo -e "${RED}[ERROR]${NC} $1"; }
        log_step() { echo -e "${BLUE}[STEP]${NC} $1"; }

        COMPOSE_FILE="docker-compose.yml"
        ENV_FILE=".env"

        log_step "üöÄ D√©marrage du d√©ploiement s√©curis√©..."

        # Arr√™t et suppression explicite des containers existants par nom
        log_info "üõë Arr√™t et suppression des containers existants..."
        CONTAINERS=("activibe-backend" "activibe-frontend" "activibe-phpmyadmin" "activibe-neo4j")
        for container in "${CONTAINERS[@]}"; do
            # Forcer l'arr√™t et la suppression sans v√©rification pr√©alable
            log_info "  Arr√™t et suppression de ${container}..."
            docker stop "${container}" 2>/dev/null || true
            docker rm -f "${container}" 2>/dev/null || true
            # V√©rifier que le conteneur a bien √©t√© supprim√©
            if docker ps -a --format '{{.Names}}' | grep -q "^${container}$"; then
                log_warning "  ‚ö†Ô∏è  Le conteneur ${container} existe encore, nouvelle tentative..."
                docker rm -f "${container}" 2>/dev/null || true
            fi
        done

        # Arr√™t propre avec docker compose si le fichier existe
        if [[ -f "$COMPOSE_FILE" ]]; then
            log_info "üõë Arr√™t avec docker compose..."
            docker compose -f "$COMPOSE_FILE" down --remove-orphans 2>/dev/null || true
            # Attendre un peu pour que les conteneurs soient bien arr√™t√©s
            sleep 2
        fi

        # Suppression finale forc√©e de tous les conteneurs par nom (au cas o√π)
        log_info "üóëÔ∏è  Suppression finale forc√©e des conteneurs..."
        for container in "${CONTAINERS[@]}"; do
            docker rm -f "${container}" 2>/dev/null || true
        done

        # Suppression explicite des r√©seaux existants
        log_info "üóëÔ∏è  Suppression des r√©seaux existants..."
        NETWORKS=("activibe_app-network" "app-network" "bookyourcoach-network")
        for network in "${NETWORKS[@]}"; do
            if docker network ls --format '{{.Name}}' | grep -q "^${network}$"; then
                log_info "  Suppression du r√©seau ${network}..."
                docker network rm "${network}" 2>/dev/null || true
            fi
        done

        # Nettoyage des ressources orphelines
        log_info "üßπ Nettoyage des ressources orphelines..."
        docker container prune -f 2>/dev/null || true
        docker network prune -f 2>/dev/null || true

        # Pull des images avec corrections de s√©curit√©
        log_info "üì• R√©cup√©ration des images avec corrections de s√©curit√©..."
        if [[ -f "$ENV_FILE" ]]; then
            source "$ENV_FILE" || true
        else
            log_warning "Fichier $ENV_FILE non trouv√© - utilisation des variables d'environnement par d√©faut"
        fi
        docker pull "$2:latest" || { log_error "Impossible de pull l'image backend"; exit 1; }
        docker pull "$3:latest" || { log_error "Impossible de pull l'image frontend"; exit 1; }

        # D√©marrage avec docker compose
        log_info "üöÄ D√©marrage des conteneurs s√©curis√©s..."
        if ! docker compose -f "$COMPOSE_FILE" up -d --remove-orphans; then
            log_error "√âchec du d√©marrage des conteneurs"
            docker compose -f "$COMPOSE_FILE" ps
            docker compose -f "$COMPOSE_FILE" logs --tail=50
            exit 1
        fi

        # Fonction pour attendre qu'un service soit pr√™t
        wait_for_service() {
            local service=$1
            local url=$2
            local max_attempts=${3:-30}
            local attempt=0
            
            log_info "‚è≥ Attente que ${service} soit pr√™t..."
            while [ $attempt -lt $max_attempts ]; do
                if curl -f -s "${url}" >/dev/null 2>&1; then
                    log_info "‚úÖ ${service} est pr√™t (tentative $((attempt + 1)))"
                    return 0
                fi
                attempt=$((attempt + 1))
                sleep 1
            done
            log_warning "‚ö†Ô∏è  ${service} n'est pas pr√™t apr√®s ${max_attempts} secondes"
            return 1
        }

        # V√©rification que les conteneurs sont d√©marr√©s
        log_info "üîç V√©rification du d√©marrage des conteneurs..."
        sleep 2
        FAILED_CONTAINERS=$(docker compose -f "$COMPOSE_FILE" ps --format json | jq -r 'select(.State == "exited" or .State == "restarting") | .Name' 2>/dev/null || true)
        if [ -n "$FAILED_CONTAINERS" ]; then
            log_error "Certains conteneurs ont √©chou√© :"
            echo "$FAILED_CONTAINERS"
            docker compose -f "$COMPOSE_FILE" ps
            docker compose -f "$COMPOSE_FILE" logs --tail=50
            exit 1
        fi

        # Attente intelligente du d√©marrage des services (maximum 30 secondes)
        log_info "‚è≥ Attente du d√©marrage des services..."
        wait_for_service "Backend" "http://localhost:8080" 30 || true
        wait_for_service "Frontend" "http://localhost:3000" 20 || true

        # Initialisation de l'application avec s√©curit√©
        log_info "üîß Initialisation de l'application..."
        MAX_RETRIES=10
        RETRY_COUNT=0
        
        # Attendre que le backend soit vraiment pr√™t
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if docker compose -f "$COMPOSE_FILE" exec -T backend php artisan --version >/dev/null 2>&1; then
                log_info "‚úÖ Backend pr√™t (tentative $((RETRY_COUNT + 1)))"
                break
            fi
            RETRY_COUNT=$((RETRY_COUNT + 1))
            log_warning "Tentative $RETRY_COUNT/$MAX_RETRIES - Attente du backend..."
            sleep 3
        done
        
        if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            log_error "Impossible d'ex√©cuter les commandes artisan - le backend n'est pas pr√™t"
            docker compose -f "$COMPOSE_FILE" logs backend --tail=50
        else
            # Nettoyage complet de tous les caches et r√©g√©n√©ration de l'autoloader
            log_info "üßπ Nettoyage complet des caches..."
            
            # Supprimer manuellement les fichiers de cache corrompus
            docker compose -f "$COMPOSE_FILE" exec -T backend rm -rf bootstrap/cache/*.php 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend rm -rf storage/framework/cache/data/* 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend rm -rf storage/framework/views/* 2>/dev/null || true
            
            # Nettoyer avec artisan
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan optimize:clear 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan config:clear 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan cache:clear 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan route:clear 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan view:clear 2>/dev/null || true
            
            # R√©g√©n√©rer l'autoloader Composer (important pour les service providers)
            log_info "üîÑ R√©g√©n√©ration de l'autoloader Composer..."
            docker compose -f "$COMPOSE_FILE" exec -T backend composer dump-autoload --optimize 2>/dev/null || true
            
            # Recr√©er les caches optimis√©s (sans view:cache car cela peut causer des probl√®mes)
            log_info "‚ö° Optimisation des caches..."
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan config:cache 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan route:cache 2>/dev/null || true
            
            # V√©rifier que l'application fonctionne
            log_info "üîç V√©rification de l'application..."
            sleep 3
            
            # Test rapide pour v√©rifier que le service view est disponible
            if docker compose -f "$COMPOSE_FILE" exec -T backend php artisan tinker --execute="app('view'); echo 'OK';" 2>/dev/null | grep -q "OK"; then
                log_info "‚úÖ Service 'view' disponible"
            else
                log_warning "‚ö†Ô∏è  Service 'view' non disponible - red√©marrage du conteneur..."
                docker compose -f "$COMPOSE_FILE" restart backend
                sleep 5
            fi
        fi

        # V√©rification de l'√©tat des services
        log_step "üîç V√©rification de l'√©tat des services..."
        docker compose -f "$COMPOSE_FILE" ps

        # Tests de connectivit√© et s√©curit√©
        log_step "üß™ Tests de connectivit√© et s√©curit√©..."
        
        # Test du backend Laravel (port 8080) avec diagnostic d√©taill√©
        backend_response=$(curl -s -w "\n%{http_code}" http://localhost:8080 2>/dev/null)
        backend_http_code=$(echo "$backend_response" | tail -n 1)
        
        if [ "$backend_http_code" = "200" ] || [ "$backend_http_code" = "302" ] || [ "$backend_http_code" = "404" ]; then
            log_info "‚úÖ Port 8080 (Backend Laravel) : Accessible (HTTP $backend_http_code)"
        elif [ "$backend_http_code" = "500" ]; then
            log_error "‚ùå Port 8080 (Backend Laravel) : Erreur serveur (HTTP 500)"
            log_info "üìã V√©rification des logs du backend..."
            docker compose -f "$COMPOSE_FILE" logs backend --tail=30
            log_info "üîß Tentative de correction compl√®te..."
            
            # Supprimer les caches corrompus
            docker compose -f "$COMPOSE_FILE" exec -T backend rm -rf bootstrap/cache/*.php 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend rm -rf storage/framework/cache/data/* 2>/dev/null || true
            
            # Nettoyer et r√©g√©n√©rer
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan optimize:clear 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend composer dump-autoload --optimize 2>/dev/null || true
            docker compose -f "$COMPOSE_FILE" exec -T backend php artisan config:cache 2>/dev/null || true
            
            # Red√©marrer le conteneur
            log_info "üîÑ Red√©marrage du conteneur backend..."
            docker compose -f "$COMPOSE_FILE" restart backend
            sleep 5
        else
            log_warning "‚ö†Ô∏è  Port 8080 (Backend Laravel) : Non accessible (HTTP ${backend_http_code:-unknown})"
        fi

        # Test de s√©curit√© des routes admin (seulement si le backend r√©pond correctement)
        if [ "$backend_http_code" != "500" ] && [ -n "$backend_http_code" ]; then
            admin_response=$(curl -s -w "\n%{http_code}" -H "Authorization: Bearer invalid_token" http://localhost:8080/api/admin/dashboard 2>/dev/null)
            admin_http_code=$(echo "$admin_response" | tail -n 1)
            
            if [ "$admin_http_code" = "401" ]; then
                log_info "‚úÖ Routes admin s√©curis√©es (HTTP $admin_http_code)"
            else
                log_warning "‚ö†Ô∏è  Routes admin non s√©curis√©es (HTTP $admin_http_code)"
            fi

            # Test de s√©curit√© des routes teacher
            teacher_response=$(curl -s -w "\n%{http_code}" -H "Authorization: Bearer invalid_token" http://localhost:8080/api/teacher/dashboard 2>/dev/null)
            teacher_http_code=$(echo "$teacher_response" | tail -n 1)
            
            if [ "$teacher_http_code" = "401" ]; then
                log_info "‚úÖ Routes teacher s√©curis√©es (HTTP $teacher_http_code)"
            else
                log_warning "‚ö†Ô∏è  Routes teacher non s√©curis√©es (HTTP $teacher_http_code)"
            fi
        else
            log_warning "‚ö†Ô∏è  Tests de s√©curit√© ignor√©s - backend non accessible (HTTP $backend_http_code)"
        fi

        # Test du frontend Nuxt.js (port 3000)
        if curl -f http://localhost:3000 >/dev/null 2>&1; then
            log_info "‚úÖ Port 3000 (Frontend Nuxt.js) : Accessible"
        else
            log_warning "‚ö†Ô∏è  Port 3000 (Frontend Nuxt.js) : Non accessible"
        fi

        # Test port 7474 (Neo4j)
        if curl -f http://localhost:7474 >/dev/null 2>&1; then
            log_info "‚úÖ Port 7474 (Neo4j) : Accessible"
        else
            log_warning "‚ö†Ô∏è  Port 7474 (Neo4j) : Non accessible"
        fi

        log_step "‚úÖ D√©ploiement s√©curis√© termin√© !"
        log_info "üîí Corrections de s√©curit√© appliqu√©es :"
        log_info "  - Authentification centralis√©e avec auth:sanctum"
        log_info "  - Middlewares de r√¥les appropri√©s"
        log_info "  - Suppression de l'authentification manuelle"
        log_info "  - Contr√¥leurs s√©curis√©s"
        EOF
        
        chmod +x auto-deploy-secure.sh

        echo "‚úÖ Fichiers de configuration s√©curis√©s g√©n√©r√©s avec succ√®s !"

    - name: üì§ D√©ploiement des fichiers s√©curis√©s
      run: |
        echo "üöÄ D√©ploiement des fichiers s√©curis√©s sur le serveur..."
        
        # Cr√©ation du r√©pertoire de d√©ploiement
        ssh production-server "mkdir -p /srv/activibe && cd /srv/activibe"
        
        # Copie des fichiers de configuration s√©curis√©s
        echo "üìã Copie des fichiers de configuration s√©curis√©s..."
        scp docker-compose.yml production-server:/srv/activibe/docker-compose.yml
        scp auto-deploy-secure.sh production-server:/srv/activibe/auto-deploy-secure.sh
        
        # Ex√©cution du d√©ploiement s√©curis√©
        echo "üéØ Ex√©cution du d√©ploiement s√©curis√©..."
        ssh production-server "cd /srv/activibe && chmod +x *.sh && ./auto-deploy-secure.sh '${{ needs.prepare.outputs.image_tag }}' '${{ env.IMAGE_NAME }}' '${{ env.FRONTEND_IMAGE_NAME }}'"

  # Job 6: Tests post-d√©ploiement avec s√©curit√©
  test-deployment:
    name: üß™ Tests Post-D√©ploiement S√©curis√©
    runs-on: ubuntu-latest
    needs: [prepare, deploy, generate-config]
    if: needs.prepare.outputs.should_deploy == 'true'
    
    steps:
    - name: üîë Configuration SSH
      run: |
        echo "üîß Configuration de la connexion SSH..."
        mkdir -p ~/.ssh
        echo "${{ secrets.SERVER_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        cat > ~/.ssh/config << EOF
        Host production-server
          HostName ${{ vars.SERVER_HOST }}
          User ${{ vars.SERVER_USERNAME }}
          Port ${{ vars.SERVER_PORT }}
          IdentityFile ~/.ssh/id_rsa
          StrictHostKeyChecking no
          UserKnownHostsFile /dev/null
        EOF
        
        chmod 600 ~/.ssh/config

    - name: üß™ Tests de connectivit√© et s√©curit√©
      run: |
        echo "üîç Tests de v√©rification post-d√©ploiement avec s√©curit√©..."
        
        # Fonction pour attendre qu'un service soit pr√™t via SSH
        wait_for_service_ssh() {
            local service=$1
            local url=$2
            local max_attempts=${3:-30}
            local attempt=0
            
            echo "‚è≥ Attente que ${service} soit pr√™t..."
            while [ $attempt -lt $max_attempts ]; do
                if ssh production-server "curl -f -s ${url}" >/dev/null 2>&1; then
                    echo "‚úÖ ${service} est pr√™t (tentative $((attempt + 1)))"
                    return 0
                fi
                attempt=$((attempt + 1))
                sleep 1
            done
            echo "‚ö†Ô∏è  ${service} n'est pas pr√™t apr√®s ${max_attempts} secondes"
            return 1
        }
        
        # Attente intelligente du d√©marrage des services
        wait_for_service_ssh "Backend" "http://localhost:8080" 30 || true
        wait_for_service_ssh "Frontend" "http://localhost:3000" 20 || true
        
        # Test de connectivit√© des services
        echo "üîå Test des services sur le serveur..."
        
        # Test frontend (port 3000)
        if ssh production-server "curl -f http://localhost:3000" >/dev/null 2>&1; then
          echo "‚úÖ Frontend (port 3000) : OK"
        else
          echo "‚ö†Ô∏è  Frontend (port 3000) : KO"
        fi
        
        # Test API backend (port 8080)
        if ssh production-server "curl -f http://localhost:8080" >/dev/null 2>&1; then
          echo "‚úÖ API Backend (port 8080) : OK"
        else
          echo "‚ö†Ô∏è  API Backend (port 8080) : KO"
        fi
        
        # Test Neo4j (port 7474)
        if ssh production-server "curl -f -H 'Accept: application/json' http://localhost:7474" >/dev/null 2>&1; then
          echo "‚úÖ Neo4j (port 7474) : OK"
        else
          echo "‚ö†Ô∏è  Neo4j (port 7474) : KO"
        fi
        
        # Test de l'IP priv√©e
        echo "üîå Test de l'IP priv√©e 10.0.0.244..."
        if ssh production-server "curl -f http://10.0.0.244:3000" >/dev/null 2>&1; then
          echo "‚úÖ Frontend sur 10.0.0.244:3000 : OK"
        else
          echo "‚ö†Ô∏è  Frontend sur 10.0.0.244:3000 : KO"
        fi
        
        if ssh production-server "curl -f http://10.0.0.244:8080" >/dev/null 2>&1; then
          echo "‚úÖ API sur 10.0.0.244:8080 : OK"
        else
          echo "‚ö†Ô∏è  API sur 10.0.0.244:8080 : KO"
        fi
        
        # Affichage de l'√©tat des containers
        echo "üìä √âtat des containers :"
        ssh production-server "cd /srv/activibe && docker compose -f docker-compose.yml ps"
        
        # Tests de s√©curit√© des routes
        echo "üîí Tests de s√©curit√© des routes..."
        
        # Test route admin avec token invalide
        admin_response=$(ssh production-server 'curl -s -w "%{http_code}" -H "Authorization: Bearer invalid_token" http://localhost:8080/api/admin/dashboard' 2>/dev/null)
        admin_http_code=$(echo "$admin_response" | tail -c 4)
        
        if [ "$admin_http_code" = "401" ]; then
          echo "‚úÖ Routes admin s√©curis√©es (HTTP $admin_http_code)"
        else
          echo "‚ö†Ô∏è  Routes admin non s√©curis√©es (HTTP $admin_http_code)"
        fi
        
        # Test route teacher avec token invalide
        teacher_response=$(ssh production-server 'curl -s -w "%{http_code}" -H "Authorization: Bearer invalid_token" http://localhost:8080/api/teacher/dashboard' 2>/dev/null)
        teacher_http_code=$(echo "$teacher_response" | tail -c 4)
        
        if [ "$teacher_http_code" = "401" ]; then
          echo "‚úÖ Routes teacher s√©curis√©es (HTTP $teacher_http_code)"
        else
          echo "‚ö†Ô∏è  Routes teacher non s√©curis√©es (HTTP $teacher_http_code)"
        fi
        
        # Test route student avec token invalide
        student_response=$(ssh production-server 'curl -s -w "%{http_code}" -H "Authorization: Bearer invalid_token" http://localhost:8080/api/student/dashboard' 2>/dev/null)
        student_http_code=$(echo "$student_response" | tail -c 4)
        
        if [ "$student_http_code" = "401" ]; then
          echo "‚úÖ Routes student s√©curis√©es (HTTP $student_http_code)"
        else
          echo "‚ö†Ô∏è  Routes student non s√©curis√©es (HTTP $student_http_code)"
        fi
        
        # Test API fonctionnel
        echo "üß™ Test fonctionnel de l'API..."
        if ssh production-server 'curl -s -X POST http://localhost:8080/api/auth/login -H "Content-Type: application/json" -d "{\"email\":\"test@test.com\",\"password\":\"test\"}" | grep -q "Invalid credentials"'; then
          echo "‚úÖ API fonctionnelle (endpoint login r√©pond)"
        else
          echo "‚ö†Ô∏è  API non fonctionnelle (endpoint login ne r√©pond pas correctement)"
        fi

  # Job 7: Notifications avec s√©curit√©
  notify:
    name: üìß Notifications S√©curis√©es
    runs-on: ubuntu-latest
    needs: [prepare, build-images, deploy, test-deployment]
    if: always()
    
    steps:
    - name: üìß Notification de succ√®s avec s√©curit√©
      if: needs.deploy.result == 'success' && needs.test-deployment.result == 'success'
      run: |
        echo "üéâ D√âPLOIEMENT S√âCURIS√â R√âUSSI !"
        echo ""
        echo "üåê L'application Acti'Vibe est maintenant accessible et s√©curis√©e :"
        echo "   ‚Ä¢ Frontend Nuxt.js : http://10.0.0.244:3000"
        echo "   ‚Ä¢ Backend Laravel API : http://10.0.0.244:8080"
        echo "   ‚Ä¢ phpMyAdmin : http://10.0.0.244:8082"
        echo "   ‚Ä¢ Neo4j : http://10.0.0.244:7474"
        echo ""
        echo "üê≥ Images d√©ploy√©es avec corrections de s√©curit√© :"
        echo "   ‚Ä¢ Backend: ${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.image_tag }}"
        echo "   ‚Ä¢ Frontend: ${{ env.FRONTEND_IMAGE_NAME }}:${{ needs.prepare.outputs.image_tag }}"
        echo ""
        echo "üîí Corrections de s√©curit√© appliqu√©es :"
        echo "   ‚úÖ Authentification centralis√©e avec auth:sanctum"
        echo "   ‚úÖ Middlewares de r√¥les appropri√©s (admin, teacher, student)"
        echo "   ‚úÖ Suppression de l'authentification manuelle"
        echo "   ‚úÖ Contr√¥leurs s√©curis√©s (AdminController, TeacherController, StudentController)"
        echo "   ‚úÖ Routes s√©par√©es (routes/admin.php)"
        echo "   ‚úÖ Message 'Acc√®s refus√©' corrig√©"
        echo ""
        echo "üìÖ Date : $(date)"

    - name: üö® Notification d'√©chec
      if: needs.deploy.result == 'failure' || needs.test-deployment.result == 'failure'
      run: |
        echo "‚ùå √âCHEC DU D√âPLOIEMENT S√âCURIS√â !"
        echo ""
        echo "üîç V√©rifiez les logs ci-dessus pour identifier le probl√®me."
        echo "üìã Points √† v√©rifier :"
        echo "   ‚Ä¢ Connexion SSH au serveur"
        echo "   ‚Ä¢ Variables d'environnement GitHub"
        echo "   ‚Ä¢ Disponibilit√© de DockerHub"
        echo "   ‚Ä¢ √âtat du serveur de production"
        echo "   ‚Ä¢ Corrections de s√©curit√© dans le code"
        echo ""
        echo "üÜò En cas de probl√®me persistant, connectez-vous manuellement :"
        echo "   ssh ${{ vars.SERVER_USERNAME }}@${{ vars.SERVER_HOST }}"
        echo "   cd /srv/activibe && ./auto-deploy-secure.sh"

    - name: üìä R√©sum√© du build s√©curis√©
      if: needs.build-images.result == 'success'
      run: |
        echo "‚úÖ BUILD S√âCURIS√â R√âUSSI !"
        echo ""
        echo "üèóÔ∏è Images construites avec corrections de s√©curit√© :"
        echo "   ‚Ä¢ Backend: ${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.image_tag }}"
        echo "   ‚Ä¢ Frontend: ${{ env.FRONTEND_IMAGE_NAME }}:${{ needs.prepare.outputs.image_tag }}"
        echo ""
        echo "üîí Corrections de s√©curit√© int√©gr√©es :"
        echo "   ‚úÖ Authentification centralis√©e"
        echo "   ‚úÖ Middlewares appropri√©s"
        echo "   ‚úÖ Contr√¥leurs s√©curis√©s"
        echo "   ‚úÖ Suppression de l'authentification manuelle"
        echo ""
        echo "üìÖ Date : $(date)"
