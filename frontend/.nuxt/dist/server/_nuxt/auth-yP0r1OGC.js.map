{"version":3,"file":"auth-yP0r1OGC.js","sources":["../../../../node_modules/nuxt/dist/app/composables/cookie.js","../../../../stores/auth.ts"],"sourcesContent":["import { customRef, getCurrentScope, nextTick, onScopeDispose, ref, watch } from \"vue\";\nimport { parse, serialize } from \"cookie-es\";\nimport { deleteCookie, getCookie, getRequestHeader, setCookie } from \"h3\";\nimport destr from \"destr\";\nimport { isEqual } from \"ohash\";\nimport { klona } from \"klona\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { useRequestEvent } from \"./ssr.js\";\nimport { cookieStore } from \"#build/nuxt.config.mjs\";\nconst CookieDefaults = {\n  path: \"/\",\n  watch: true,\n  decode: (val) => destr(decodeURIComponent(val)),\n  encode: (val) => encodeURIComponent(typeof val === \"string\" ? val : JSON.stringify(val))\n};\nconst store = import.meta.client && cookieStore ? window.cookieStore : void 0;\nexport function useCookie(name, _opts) {\n  const opts = { ...CookieDefaults, ..._opts };\n  opts.filter ??= (key) => key === name;\n  const cookies = readRawCookies(opts) || {};\n  let delay;\n  if (opts.maxAge !== void 0) {\n    delay = opts.maxAge * 1e3;\n  } else if (opts.expires) {\n    delay = opts.expires.getTime() - Date.now();\n  }\n  const hasExpired = delay !== void 0 && delay <= 0;\n  const shouldSetInitialClientCookie = import.meta.client && (hasExpired || cookies[name] === void 0 || cookies[name] === null);\n  const cookieValue = klona(hasExpired ? void 0 : cookies[name] ?? opts.default?.());\n  const cookie = import.meta.client && delay && !hasExpired ? cookieRef(cookieValue, delay, opts.watch && opts.watch !== \"shallow\") : ref(cookieValue);\n  if (import.meta.dev && hasExpired) {\n    console.warn(`[nuxt] not setting cookie \\`${name}\\` as it has already expired.`);\n  }\n  if (import.meta.client) {\n    let channel = null;\n    try {\n      if (!store && typeof BroadcastChannel !== \"undefined\") {\n        channel = new BroadcastChannel(`nuxt:cookies:${name}`);\n      }\n    } catch {\n    }\n    const callback = (force = false) => {\n      if (!force) {\n        if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n          return;\n        }\n      }\n      writeClientCookie(name, cookie.value, opts);\n      cookies[name] = klona(cookie.value);\n      channel?.postMessage({ value: opts.encode(cookie.value) });\n    };\n    const handleChange = (data) => {\n      const value = data.refresh ? readRawCookies(opts)?.[name] : opts.decode(data.value);\n      watchPaused = true;\n      cookie.value = value;\n      cookies[name] = klona(value);\n      nextTick(() => {\n        watchPaused = false;\n      });\n    };\n    let watchPaused = false;\n    const hasScope = !!getCurrentScope();\n    if (hasScope) {\n      onScopeDispose(() => {\n        watchPaused = true;\n        callback();\n        channel?.close();\n      });\n    }\n    if (store) {\n      const changeHandler = (event) => {\n        const changedCookie = event.changed.find((c) => c.name === name);\n        const removedCookie = event.deleted.find((c) => c.name === name);\n        if (changedCookie) {\n          handleChange({ value: changedCookie.value });\n        }\n        if (removedCookie) {\n          handleChange({ value: null });\n        }\n      };\n      store.addEventListener(\"change\", changeHandler);\n      if (hasScope) {\n        onScopeDispose(() => store.removeEventListener(\"change\", changeHandler));\n      }\n    } else if (channel) {\n      channel.onmessage = ({ data }) => handleChange(data);\n    }\n    if (opts.watch) {\n      watch(\n        cookie,\n        () => {\n          if (watchPaused) {\n            return;\n          }\n          callback();\n        },\n        { deep: opts.watch !== \"shallow\" }\n      );\n    }\n    if (shouldSetInitialClientCookie) {\n      callback(shouldSetInitialClientCookie);\n    }\n  } else if (import.meta.server) {\n    const nuxtApp = useNuxtApp();\n    const writeFinalCookieValue = () => {\n      if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n        return;\n      }\n      nuxtApp._cookies ||= {};\n      if (name in nuxtApp._cookies) {\n        if (isEqual(cookie.value, nuxtApp._cookies[name])) {\n          return;\n        }\n        if (import.meta.dev) {\n          console.warn(`[nuxt] cookie \\`${name}\\` was previously set to \\`${opts.encode(nuxtApp._cookies[name])}\\` and is being overridden to \\`${opts.encode(cookie.value)}\\`. This may cause unexpected issues.`);\n        }\n      }\n      nuxtApp._cookies[name] = cookie.value;\n      writeServerCookie(useRequestEvent(nuxtApp), name, cookie.value, opts);\n    };\n    const unhook = nuxtApp.hooks.hookOnce(\"app:rendered\", writeFinalCookieValue);\n    nuxtApp.hooks.hookOnce(\"app:error\", () => {\n      unhook();\n      return writeFinalCookieValue();\n    });\n  }\n  return cookie;\n}\nexport function refreshCookie(name) {\n  if (import.meta.server || store || typeof BroadcastChannel === \"undefined\") {\n    return;\n  }\n  new BroadcastChannel(`nuxt:cookies:${name}`)?.postMessage({ refresh: true });\n}\nfunction readRawCookies(opts = {}) {\n  if (import.meta.server) {\n    return parse(getRequestHeader(useRequestEvent(), \"cookie\") || \"\", opts);\n  } else if (import.meta.client) {\n    return parse(document.cookie, opts);\n  }\n}\nfunction serializeCookie(name, value, opts = {}) {\n  if (value === null || value === void 0) {\n    return serialize(name, value, { ...opts, maxAge: -1 });\n  }\n  return serialize(name, value, opts);\n}\nfunction writeClientCookie(name, value, opts = {}) {\n  if (import.meta.client) {\n    document.cookie = serializeCookie(name, value, opts);\n  }\n}\nfunction writeServerCookie(event, name, value, opts = {}) {\n  if (event) {\n    if (value !== null && value !== void 0) {\n      return setCookie(event, name, value, opts);\n    }\n    if (getCookie(event, name) !== void 0) {\n      return deleteCookie(event, name, opts);\n    }\n  }\n}\nconst MAX_TIMEOUT_DELAY = 2147483647;\nfunction cookieRef(value, delay, shouldWatch) {\n  let timeout;\n  let unsubscribe;\n  let elapsed = 0;\n  const internalRef = shouldWatch ? ref(value) : { value };\n  if (getCurrentScope()) {\n    onScopeDispose(() => {\n      unsubscribe?.();\n      clearTimeout(timeout);\n    });\n  }\n  return customRef((track, trigger) => {\n    if (shouldWatch) {\n      unsubscribe = watch(internalRef, trigger);\n    }\n    function createExpirationTimeout() {\n      elapsed = 0;\n      clearTimeout(timeout);\n      const timeRemaining = delay - elapsed;\n      const timeoutLength = timeRemaining < MAX_TIMEOUT_DELAY ? timeRemaining : MAX_TIMEOUT_DELAY;\n      timeout = setTimeout(() => {\n        elapsed += timeoutLength;\n        if (elapsed < delay) {\n          return createExpirationTimeout();\n        }\n        internalRef.value = void 0;\n        trigger();\n      }, timeoutLength);\n    }\n    return {\n      get() {\n        track();\n        return internalRef.value;\n      },\n      set(newValue) {\n        createExpirationTimeout();\n        internalRef.value = newValue;\n        trigger();\n      }\n    };\n  });\n}\n","import { defineStore } from 'pinia'\n\ninterface User {\n    id: number\n    name: string\n    email: string\n    role: 'admin' | 'teacher' | 'student'\n    is_active: boolean\n    profile?: any\n    teacher?: any\n    student?: any\n}\n\ninterface AuthState {\n    user: User | null\n    token: string | null\n    isAuthenticated: boolean\n    loading: boolean\n}\n\nexport const useAuthStore = defineStore('auth', {\n    state: (): AuthState => ({\n        user: null,\n        token: null,\n        isAuthenticated: false,\n        loading: false\n    }),\n\n    getters: {\n        isAdmin: (state) => state.user?.role === 'admin',\n        isTeacher: (state) => state.user?.role === 'teacher',\n        isStudent: (state) => state.user?.role === 'student',\n        userName: (state) => state.user?.name || 'Utilisateur'\n    },\n\n    actions: {\n        async login(credentials: { email: string, password: string }) {\n            this.loading = true\n            try {\n                const { $api } = useNuxtApp()\n                const response = await $api.post('/auth/login', credentials)\n\n                this.token = response.data.token\n                this.user = response.data.user\n                this.isAuthenticated = true\n\n                // Stocker le token\n                const tokenCookie = useCookie('auth-token', {\n                    httpOnly: false,\n                    secure: false,\n                    maxAge: 60 * 60 * 24 * 7 // 7 jours\n                })\n                tokenCookie.value = this.token\n\n                return response.data\n            } catch (error) {\n                throw error\n            } finally {\n                this.loading = false\n            }\n        },\n\n        async register(userData: {\n            name: string\n            email: string\n            password: string\n            password_confirmation: string\n        }) {\n            this.loading = true\n            try {\n                const { $api } = useNuxtApp()\n                const response = await $api.post('/auth/register', userData)\n\n                this.token = response.data.token\n                this.user = response.data.user\n                this.isAuthenticated = true\n\n                // Stocker le token\n                const tokenCookie = useCookie('auth-token')\n                tokenCookie.value = this.token\n\n                return response.data\n            } catch (error) {\n                throw error\n            } finally {\n                this.loading = false\n            }\n        },\n\n        async logout() {\n            try {\n                const { $api } = useNuxtApp()\n                await $api.post('/auth/logout')\n            } catch (error) {\n                console.error('Erreur lors de la déconnexion:', error)\n            } finally {\n                this.user = null\n                this.token = null\n                this.isAuthenticated = false\n\n                // Supprimer le token\n                const tokenCookie = useCookie('auth-token')\n                tokenCookie.value = null\n\n                // Nettoyer le localStorage si présent\n                if (process.client) {\n                    localStorage.removeItem('auth-token')\n                    localStorage.removeItem('user-data')\n                }\n\n                await navigateTo('/login')\n            }\n        },\n\n        async fetchUser() {\n            if (!this.token) return\n\n            try {\n                const { $api } = useNuxtApp()\n                const response = await $api.get('/auth/user')\n                this.user = response.data.user || response.data\n                this.isAuthenticated = true\n\n                // Sauvegarder les données utilisateur localement\n                if (process.client) {\n                    localStorage.setItem('user-data', JSON.stringify(this.user))\n                }\n            } catch (error: any) {\n                console.error('Erreur lors de la récupération de l\\'utilisateur:', error)\n\n                // Si c'est une erreur 401 (token expiré), déconnecter silencieusement\n                if (error.response?.status === 401) {\n                    this.user = null\n                    this.token = null\n                    this.isAuthenticated = false\n\n                    const tokenCookie = useCookie('auth-token')\n                    tokenCookie.value = null\n\n                    if (process.client) {\n                        localStorage.removeItem('auth-token')\n                        localStorage.removeItem('user-data')\n                    }\n                }\n\n                throw error\n            }\n        },\n\n        async initializeAuth() {\n            if (process.client) {\n                const tokenCookie = useCookie('auth-token')\n                if (tokenCookie.value) {\n                    this.token = tokenCookie.value\n\n                    // Essayer de récupérer les données utilisateur depuis localStorage\n                    const userData = localStorage.getItem('user-data')\n                    if (userData) {\n                        try {\n                            this.user = JSON.parse(userData)\n                            this.isAuthenticated = true\n                        } catch (e) {\n                            console.warn('Données utilisateur corrompues dans localStorage')\n                        }\n                    }\n\n                    // Vérifier la validité du token de manière synchrone\n                    try {\n                        const isValid = await this.verifyToken()\n                        if (!isValid) {\n                            console.warn('Token invalide lors de la vérification')\n                            // Token invalide, rediriger vers login\n                            await navigateTo('/login')\n                        }\n                    } catch (error) {\n                        console.error('Erreur lors de la vérification du token:', error)\n                        // En cas d'erreur, rediriger vers login\n                        await navigateTo('/login')\n                    }\n                }\n            }\n        },\n\n        // Nouvelle méthode pour forcer la vérification du token\n        async verifyToken() {\n            if (!this.token) {\n                return false\n            }\n\n            try {\n                await this.fetchUser()\n                return true\n            } catch (error: any) {\n                if (error.response?.status === 401) {\n                    // Nettoyer les données d'authentification\n                    this.user = null\n                    this.token = null\n                    this.isAuthenticated = false\n\n                    const tokenCookie = useCookie('auth-token')\n                    tokenCookie.value = null\n\n                    if (process.client) {\n                        localStorage.removeItem('auth-token')\n                        localStorage.removeItem('user-data')\n                    }\n                }\n                return false\n            }\n        }\n    }\n})\n"],"names":[],"mappings":";;;;;;;;AASA,MAAM,iBAAiB;AAAA,EACrB,MAAM;AAAA,EACN,OAAO;AAAA,EACP,QAAQ,CAAC,QAAQ,MAAM,mBAAmB,GAAG,CAAC;AAAA,EAC9C,QAAQ,CAAC,QAAQ,mBAAmB,OAAO,QAAQ,WAAW,MAAM,KAAK,UAAU,GAAG,CAAC;AACzF;AAEO,SAAS,UAAU,MAAM,OAAO;;AACrC,QAAM,OAAO,EAAE,GAAG,gBAAgB,GAAG,MAAA;AACrC,OAAK,WAAL,KAAK,SAAW,CAAC,QAAQ,QAAQ;AACjC,QAAM,UAAU,eAAe,IAAI,KAAK,CAAA;AACxC,MAAI;AACJ,MAAI,KAAK,WAAW,QAAQ;AAC1B,YAAQ,KAAK,SAAS;AAAA,EACxB,WAAW,KAAK,SAAS;AACvB,YAAQ,KAAK,QAAQ,QAAA,IAAY,KAAK,IAAA;AAAA,EACxC;AACA,QAAM,aAAa,UAAU,UAAU,SAAS;AAEhD,QAAM,cAAc,MAAM,aAAa,SAAS,QAAQ,IAAI,OAAK,UAAK,YAAL,8BAAgB;AACjF,QAAM,SAA8H,IAAI,WAAW;AAyEpH;AAC7B,UAAM,UAAU,WAAA;AAChB,UAAM,wBAAwB,MAAM;AAClC,UAAI,KAAK,YAAY,QAAQ,OAAO,OAAO,QAAQ,IAAI,CAAC,GAAG;AACzD;AAAA,MACF;AACA,cAAQ,aAAR,QAAQ,WAAa,CAAA;AACrB,UAAI,QAAQ,QAAQ,UAAU;AAC5B,YAAI,QAAQ,OAAO,OAAO,QAAQ,SAAS,IAAI,CAAC,GAAG;AACjD;AAAA,QACF;AAAA,MAIF;AACA,cAAQ,SAAS,IAAI,IAAI,OAAO;AAChC,wBAAkB,gBAAgB,OAAO,GAAG,MAAM,OAAO,OAAO,IAAI;AAAA,IACtE;AACA,UAAM,SAAS,QAAQ,MAAM,SAAS,gBAAgB,qBAAqB;AAC3E,YAAQ,MAAM,SAAS,aAAa,MAAM;AACxC,aAAA;AACA,aAAO,sBAAA;AAAA,IACT,CAAC;AAAA,EACH;AACA,SAAO;AACT;AAOA,SAAS,eAAe,OAAO,IAAI;AACT;AACtB,WAAO,MAAM,iBAAiB,gBAAA,GAAmB,QAAQ,KAAK,IAAI,IAAI;AAAA,EACxE;AAGF;AAYA,SAAS,kBAAkB,OAAO,MAAM,OAAO,OAAO,CAAA,GAAI;AACxD,MAAI,OAAO;AACT,QAAI,UAAU,QAAQ,UAAU,QAAQ;AACtC,aAAO,UAAU,OAAO,MAAM,OAAO,IAAI;AAAA,IAC3C;AACA,QAAI,UAAU,OAAO,IAAI,MAAM,QAAQ;AACrC,aAAO,aAAa,OAAO,MAAM,IAAI;AAAA,IACvC;AAAA,EACF;AACF;AC7IO,MAAM,eAAe,YAAY,QAAQ;AAAA,EAC5C,OAAO,OAAkB;AAAA,IACrB,MAAM;AAAA,IACN,OAAO;AAAA,IACP,iBAAiB;AAAA,IACjB,SAAS;AAAA,EAAA;AAAA,EAGb,SAAS;AAAA,IACL,SAAS,CAAC,UAAA;;AAAU,0BAAM,SAAN,mBAAY,UAAS;AAAA;AAAA,IACzC,WAAW,CAAC,UAAA;;AAAU,0BAAM,SAAN,mBAAY,UAAS;AAAA;AAAA,IAC3C,WAAW,CAAC,UAAA;;AAAU,0BAAM,SAAN,mBAAY,UAAS;AAAA;AAAA,IAC3C,UAAU,CAAC,UAAA;;AAAU,0BAAM,SAAN,mBAAY,SAAQ;AAAA;AAAA,EAAA;AAAA,EAG7C,SAAS;AAAA,IACL,MAAM,MAAM,aAAkD;AAC1D,WAAK,UAAU;AACf,UAAI;AACA,cAAM,EAAE,KAAA,IAAS,WAAA;AACjB,cAAM,WAAW,MAAM,KAAK,KAAK,eAAe,WAAW;AAE3D,aAAK,QAAQ,SAAS,KAAK;AAC3B,aAAK,OAAO,SAAS,KAAK;AAC1B,aAAK,kBAAkB;AAGvB,cAAM,cAAc,UAAU,cAAc;AAAA,UACxC,UAAU;AAAA,UACV,QAAQ;AAAA,UACR,QAAQ,KAAK,KAAK,KAAK;AAAA;AAAA,QAAA,CAC1B;AACD,oBAAY,QAAQ,KAAK;AAEzB,eAAO,SAAS;AAAA,MACpB,SAAS,OAAO;AACZ,cAAM;AAAA,MACV,UAAA;AACI,aAAK,UAAU;AAAA,MACnB;AAAA,IACJ;AAAA,IAEA,MAAM,SAAS,UAKZ;AACC,WAAK,UAAU;AACf,UAAI;AACA,cAAM,EAAE,KAAA,IAAS,WAAA;AACjB,cAAM,WAAW,MAAM,KAAK,KAAK,kBAAkB,QAAQ;AAE3D,aAAK,QAAQ,SAAS,KAAK;AAC3B,aAAK,OAAO,SAAS,KAAK;AAC1B,aAAK,kBAAkB;AAGvB,cAAM,cAAc,UAAU,YAAY;AAC1C,oBAAY,QAAQ,KAAK;AAEzB,eAAO,SAAS;AAAA,MACpB,SAAS,OAAO;AACZ,cAAM;AAAA,MACV,UAAA;AACI,aAAK,UAAU;AAAA,MACnB;AAAA,IACJ;AAAA,IAEA,MAAM,SAAS;AACX,UAAI;AACA,cAAM,EAAE,KAAA,IAAS,WAAA;AACjB,cAAM,KAAK,KAAK,cAAc;AAAA,MAClC,SAAS,OAAO;AACZ,gBAAQ,MAAM,kCAAkC,KAAK;AAAA,MACzD,UAAA;AACI,aAAK,OAAO;AACZ,aAAK,QAAQ;AACb,aAAK,kBAAkB;AAGvB,cAAM,cAAc,UAAU,YAAY;AAC1C,oBAAY,QAAQ;AAQpB,cAAM,WAAW,QAAQ;AAAA,MAC7B;AAAA,IACJ;AAAA,IAEA,MAAM,YAAY;;AACd,UAAI,CAAC,KAAK,MAAO;AAEjB,UAAI;AACA,cAAM,EAAE,KAAA,IAAS,WAAA;AACjB,cAAM,WAAW,MAAM,KAAK,IAAI,YAAY;AAC5C,aAAK,OAAO,SAAS,KAAK,QAAQ,SAAS;AAC3C,aAAK,kBAAkB;AAGvB,YAAI,MAAgB;AAAA,MAGxB,SAAS,OAAY;AACjB,gBAAQ,MAAM,oDAAqD,KAAK;AAGxE,cAAI,WAAM,aAAN,mBAAgB,YAAW,KAAK;AAChC,eAAK,OAAO;AACZ,eAAK,QAAQ;AACb,eAAK,kBAAkB;AAEvB,gBAAM,cAAc,UAAU,YAAY;AAC1C,sBAAY,QAAQ;AAAA,QAMxB;AAEA,cAAM;AAAA,MACV;AAAA,IACJ;AAAA,IAEA,MAAM,iBAAiB;AAAA,IAgCvB;AAAA;AAAA,IAGA,MAAM,cAAc;;AAChB,UAAI,CAAC,KAAK,OAAO;AACb,eAAO;AAAA,MACX;AAEA,UAAI;AACA,cAAM,KAAK,UAAA;AACX,eAAO;AAAA,MACX,SAAS,OAAY;AACjB,cAAI,WAAM,aAAN,mBAAgB,YAAW,KAAK;AAEhC,eAAK,OAAO;AACZ,eAAK,QAAQ;AACb,eAAK,kBAAkB;AAEvB,gBAAM,cAAc,UAAU,YAAY;AAC1C,sBAAY,QAAQ;AAAA,QAMxB;AACA,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,EAAA;AAER,CAAC;","x_google_ignoreList":[0]}